// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.36.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'exception_twin_rust_async_sse.freezed.dart';

Future<int> funcReturnErrorTwinRustAsyncSse({dynamic hint}) => RustLib
    .instance.api
    .crateApiPseudoManualExceptionTwinRustAsyncSseFuncReturnErrorTwinRustAsyncSse(
        hint: hint);

Future<int> funcTypeFalliblePanicTwinRustAsyncSse({dynamic hint}) => RustLib
    .instance.api
    .crateApiPseudoManualExceptionTwinRustAsyncSseFuncTypeFalliblePanicTwinRustAsyncSse(
        hint: hint);

Future<int> funcTypeInfalliblePanicTwinRustAsyncSse({dynamic hint}) => RustLib
    .instance.api
    .crateApiPseudoManualExceptionTwinRustAsyncSseFuncTypeInfalliblePanicTwinRustAsyncSse(
        hint: hint);

Future<int> customEnumErrorReturnOkTwinRustAsyncSse(
        {required int arg, dynamic hint}) =>
    RustLib.instance.api
        .crateApiPseudoManualExceptionTwinRustAsyncSseCustomEnumErrorReturnOkTwinRustAsyncSse(
            arg: arg, hint: hint);

Future<void> customEnumErrorPanicTwinRustAsyncSse({dynamic hint}) => RustLib
    .instance.api
    .crateApiPseudoManualExceptionTwinRustAsyncSseCustomEnumErrorPanicTwinRustAsyncSse(
        hint: hint);

Future<int> customEnumErrorReturnErrorTwinRustAsyncSse({dynamic hint}) => RustLib
    .instance.api
    .crateApiPseudoManualExceptionTwinRustAsyncSseCustomEnumErrorReturnErrorTwinRustAsyncSse(
        hint: hint);

Future<void> customNestedErrorReturnErrorTwinRustAsyncSse(
        {required CustomNestedErrorOuterTwinRustAsyncSse arg, dynamic hint}) =>
    RustLib.instance.api
        .crateApiPseudoManualExceptionTwinRustAsyncSseCustomNestedErrorReturnErrorTwinRustAsyncSse(
            arg: arg, hint: hint);

Future<void> customStructErrorReturnErrorTwinRustAsyncSse(
        {required CustomStructErrorTwinRustAsyncSse arg, dynamic hint}) =>
    RustLib.instance.api
        .crateApiPseudoManualExceptionTwinRustAsyncSseCustomStructErrorReturnErrorTwinRustAsyncSse(
            arg: arg, hint: hint);

Future<int> returnErrCustomErrorTwinRustAsyncSse({dynamic hint}) => RustLib
    .instance.api
    .crateApiPseudoManualExceptionTwinRustAsyncSseReturnErrCustomErrorTwinRustAsyncSse(
        hint: hint);

Future<int> returnOkCustomErrorTwinRustAsyncSse({dynamic hint}) => RustLib
    .instance.api
    .crateApiPseudoManualExceptionTwinRustAsyncSseReturnOkCustomErrorTwinRustAsyncSse(
        hint: hint);

Future<int> returnErrorVariantTwinRustAsyncSse(
        {required int variant, dynamic hint}) =>
    RustLib.instance.api
        .crateApiPseudoManualExceptionTwinRustAsyncSseReturnErrorVariantTwinRustAsyncSse(
            variant: variant, hint: hint);

Future<void> returnCustomNestedError1TwinRustAsyncSse({dynamic hint}) => RustLib
    .instance.api
    .crateApiPseudoManualExceptionTwinRustAsyncSseReturnCustomNestedError1TwinRustAsyncSse(
        hint: hint);

Future<void> returnCustomNestedError1Variant1TwinRustAsyncSse({dynamic hint}) =>
    RustLib.instance.api
        .crateApiPseudoManualExceptionTwinRustAsyncSseReturnCustomNestedError1Variant1TwinRustAsyncSse(
            hint: hint);

Future<void> returnCustomNestedError2TwinRustAsyncSse({dynamic hint}) => RustLib
    .instance.api
    .crateApiPseudoManualExceptionTwinRustAsyncSseReturnCustomNestedError2TwinRustAsyncSse(
        hint: hint);

Future<void> returnCustomStructErrorTwinRustAsyncSse({dynamic hint}) => RustLib
    .instance.api
    .crateApiPseudoManualExceptionTwinRustAsyncSseReturnCustomStructErrorTwinRustAsyncSse(
        hint: hint);

Future<int> returnCustomStructOkTwinRustAsyncSse({dynamic hint}) => RustLib
    .instance.api
    .crateApiPseudoManualExceptionTwinRustAsyncSseReturnCustomStructOkTwinRustAsyncSse(
        hint: hint);

Future<void> throwAnyhowTwinRustAsyncSse({dynamic hint}) => RustLib.instance.api
    .crateApiPseudoManualExceptionTwinRustAsyncSseThrowAnyhowTwinRustAsyncSse(
        hint: hint);

Future<void> panicWithCustomResultTwinRustAsyncSse({dynamic hint}) => RustLib
    .instance.api
    .crateApiPseudoManualExceptionTwinRustAsyncSsePanicWithCustomResultTwinRustAsyncSse(
        hint: hint);

Future<
    Stream<
        String>> streamSinkThrowAnyhowTwinRustAsyncSse({dynamic hint}) => RustLib
    .instance.api
    .crateApiPseudoManualExceptionTwinRustAsyncSseStreamSinkThrowAnyhowTwinRustAsyncSse(
        hint: hint);

@freezed
sealed class CustomEnumErrorTwinRustAsyncSse
    with _$CustomEnumErrorTwinRustAsyncSse
    implements FrbException {
  const CustomEnumErrorTwinRustAsyncSse._();

  @Implements<FrbBacktracedException>()
  const factory CustomEnumErrorTwinRustAsyncSse.one({
    required String message,
    required String backtrace,
  }) = CustomEnumErrorTwinRustAsyncSse_One;
  @Implements<FrbBacktracedException>()
  const factory CustomEnumErrorTwinRustAsyncSse.two({
    required int message,
    required String backtrace,
  }) = CustomEnumErrorTwinRustAsyncSse_Two;
}

@freezed
sealed class CustomErrorTwinRustAsyncSse
    with _$CustomErrorTwinRustAsyncSse
    implements FrbException {
  const CustomErrorTwinRustAsyncSse._();

  @Implements<FrbBacktracedException>()
  const factory CustomErrorTwinRustAsyncSse.error0({
    required String e,
    required String backtrace,
  }) = CustomErrorTwinRustAsyncSse_Error0;
  @Implements<FrbBacktracedException>()
  const factory CustomErrorTwinRustAsyncSse.error1({
    required int e,
    required String backtrace,
  }) = CustomErrorTwinRustAsyncSse_Error1;
}

@freezed
sealed class CustomNestedError1TwinRustAsyncSse
    with _$CustomNestedError1TwinRustAsyncSse
    implements FrbException {
  const CustomNestedError1TwinRustAsyncSse._();

  const factory CustomNestedError1TwinRustAsyncSse.customNested1(
    String field0,
  ) = CustomNestedError1TwinRustAsyncSse_CustomNested1;
  const factory CustomNestedError1TwinRustAsyncSse.errorNested(
    CustomNestedError2TwinRustAsyncSse field0,
  ) = CustomNestedError1TwinRustAsyncSse_ErrorNested;
}

@freezed
sealed class CustomNestedError2TwinRustAsyncSse
    with _$CustomNestedError2TwinRustAsyncSse {
  const CustomNestedError2TwinRustAsyncSse._();

  const factory CustomNestedError2TwinRustAsyncSse.customNested2(
    String field0,
  ) = CustomNestedError2TwinRustAsyncSse_CustomNested2;
  const factory CustomNestedError2TwinRustAsyncSse.customNested2Number(
    int field0,
  ) = CustomNestedError2TwinRustAsyncSse_CustomNested2Number;
}

@freezed
sealed class CustomNestedErrorInnerTwinRustAsyncSse
    with _$CustomNestedErrorInnerTwinRustAsyncSse {
  const CustomNestedErrorInnerTwinRustAsyncSse._();

  const factory CustomNestedErrorInnerTwinRustAsyncSse.three(
    String field0,
  ) = CustomNestedErrorInnerTwinRustAsyncSse_Three;
  const factory CustomNestedErrorInnerTwinRustAsyncSse.four(
    int field0,
  ) = CustomNestedErrorInnerTwinRustAsyncSse_Four;
}

@freezed
sealed class CustomNestedErrorOuterTwinRustAsyncSse
    with _$CustomNestedErrorOuterTwinRustAsyncSse {
  const CustomNestedErrorOuterTwinRustAsyncSse._();

  const factory CustomNestedErrorOuterTwinRustAsyncSse.one(
    String field0,
  ) = CustomNestedErrorOuterTwinRustAsyncSse_One;
  const factory CustomNestedErrorOuterTwinRustAsyncSse.two(
    CustomNestedErrorInnerTwinRustAsyncSse field0,
  ) = CustomNestedErrorOuterTwinRustAsyncSse_Two;
}

class CustomStructErrorAnotherTwinRustAsyncSse implements FrbException {
  final String message;

  const CustomStructErrorAnotherTwinRustAsyncSse({
    required this.message,
  });

  @override
  int get hashCode => message.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CustomStructErrorAnotherTwinRustAsyncSse &&
          runtimeType == other.runtimeType &&
          message == other.message;
}

class CustomStructErrorTwinRustAsyncSse {
  final String a;

  const CustomStructErrorTwinRustAsyncSse({
    required this.a,
  });

  @override
  int get hashCode => a.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CustomStructErrorTwinRustAsyncSse &&
          runtimeType == other.runtimeType &&
          a == other.a;
}

class CustomStructTwinRustAsyncSse {
  final String message;

  const CustomStructTwinRustAsyncSse({
    required this.message,
  });

  static Future<CustomStructTwinRustAsyncSse> newTwinRustAsyncSse(
          {required String message, dynamic hint}) =>
      RustLib.instance.api
          .crateApiPseudoManualExceptionTwinRustAsyncSseCustomStructTwinRustAsyncSseNewTwinRustAsyncSse(
              message: message, hint: hint);

  Future<void> nonstaticReturnCustomStructErrorTwinRustAsyncSse(
          {dynamic hint}) =>
      RustLib.instance.api
          .crateApiPseudoManualExceptionTwinRustAsyncSseCustomStructTwinRustAsyncSseNonstaticReturnCustomStructErrorTwinRustAsyncSse(
              that: this, hint: hint);

  Future<int> nonstaticReturnCustomStructOkTwinRustAsyncSse({dynamic hint}) =>
      RustLib.instance.api
          .crateApiPseudoManualExceptionTwinRustAsyncSseCustomStructTwinRustAsyncSseNonstaticReturnCustomStructOkTwinRustAsyncSse(
              that: this, hint: hint);

  static Future<void> staticReturnCustomStructErrorTwinRustAsyncSse(
          {dynamic hint}) =>
      RustLib.instance.api
          .crateApiPseudoManualExceptionTwinRustAsyncSseCustomStructTwinRustAsyncSseStaticReturnCustomStructErrorTwinRustAsyncSse(
              hint: hint);

  static Future<int> staticReturnCustomStructOkTwinRustAsyncSse(
          {dynamic hint}) =>
      RustLib.instance.api
          .crateApiPseudoManualExceptionTwinRustAsyncSseCustomStructTwinRustAsyncSseStaticReturnCustomStructOkTwinRustAsyncSse(
              hint: hint);

  @override
  int get hashCode => message.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CustomStructTwinRustAsyncSse &&
          runtimeType == other.runtimeType &&
          message == other.message;
}

class SomeStructTwinRustAsyncSse {
  final int value;

  const SomeStructTwinRustAsyncSse({
    required this.value,
  });

  static Future<SomeStructTwinRustAsyncSse> newTwinRustAsyncSse(
          {required int value, dynamic hint}) =>
      RustLib.instance.api
          .crateApiPseudoManualExceptionTwinRustAsyncSseSomeStructTwinRustAsyncSseNewTwinRustAsyncSse(
              value: value, hint: hint);

  Future<int> nonStaticReturnErrCustomErrorTwinRustAsyncSse({dynamic hint}) =>
      RustLib.instance.api
          .crateApiPseudoManualExceptionTwinRustAsyncSseSomeStructTwinRustAsyncSseNonStaticReturnErrCustomErrorTwinRustAsyncSse(
              that: this, hint: hint);

  Future<int> nonStaticReturnOkCustomErrorTwinRustAsyncSse({dynamic hint}) =>
      RustLib.instance.api
          .crateApiPseudoManualExceptionTwinRustAsyncSseSomeStructTwinRustAsyncSseNonStaticReturnOkCustomErrorTwinRustAsyncSse(
              that: this, hint: hint);

  static Future<int> staticReturnErrCustomErrorTwinRustAsyncSse(
          {dynamic hint}) =>
      RustLib.instance.api
          .crateApiPseudoManualExceptionTwinRustAsyncSseSomeStructTwinRustAsyncSseStaticReturnErrCustomErrorTwinRustAsyncSse(
              hint: hint);

  static Future<int> staticReturnOkCustomErrorTwinRustAsyncSse(
          {dynamic hint}) =>
      RustLib.instance.api
          .crateApiPseudoManualExceptionTwinRustAsyncSseSomeStructTwinRustAsyncSseStaticReturnOkCustomErrorTwinRustAsyncSse(
              hint: hint);

  @override
  int get hashCode => value.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SomeStructTwinRustAsyncSse &&
          runtimeType == other.runtimeType &&
          value == other.value;
}
